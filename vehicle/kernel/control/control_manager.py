import time
import asyncio
import grpc
import zmq
import zmq.asyncio
from concurrent import futures
# Service imports
from kernel.control.report_service import ReportService
from kernel.control.control_proxy_service import ControlProxyService
# Utility imports
from util.config import query_config
from util.custom_logger import CustomLogger
from util.sockets import setup_zmq_socket, SocketOperation
from util.auth import ControlAuth
from util.command_multiplexer import CommandMultiplexer
# Protocol imports
from python_bindings import control_pb2 as control_proto
from python_bindings.report_service_pb2_grpc import add_ReportServicer_to_server
from python_bindings.mission_service_pb2_grpc import MissionStub
from python_bindings.driver_service_pb2_grpc import DriverStub, add_DriverServicer_to_server

class ControlMode:
    '''
    Mode switch to determine which entity has control of the vehicle.
    Must be wrapped in a class so it is pass-by-reference.
    -----------------------------------------------
    ControlMode.REMOTE -> Swarm Controller commands
    ControlMode.LOCAL -> Mission commands
    ControlMode.RC -> Remote control joystick commands
    -----------------------------------------------
    '''
    def __init__(self, mode=control_proto.ControlMode.REMOTE):
        self._mode = mode

    def get_mode(self):
        return self._mode

    def switch_mode(self, mode):
        self._mode = mode

mode = ControlMode()

# Create ZeroMQ socket that connects to the Swarm Controller
command_socket = zmq.Context().socket(zmq.DEALER)
setup_zmq_socket(
    command_socket,
    'cloudlet.swarm_controller.endpoint',
    SocketOperation.CONNECT
    )

async def handle_swarm_control():
    '''
    Handles input from the Swarm Controller for remote operation, mission 
    start/stop, and mission notification.
    '''
    # Read relevant endpoints from the config
    driver_addr = query_config('driver.control_service.endpoint')
    mission_addr = query_config('mission.mission_service.endpoint')

    # Setup logger
    logger = CustomLogger('/kernel/swarm_control')

    # Setup clients
    async with grpc.aio.insecure_channel(driver_addr) as driver_channel, \
            grpc.aio.insecure_channel(mission_addr) as mission_channel:
        # Get the driver stub wrapper which will help us translate
        # Swarm Controller commands into stub calls
        driver_stub = DriverStub(driver_channel)

        # Get the mission stub
        mission_stub = MissionStub(mission_channel) 

        # Create a command multiplexer that will send Swarm Controller
        # messages to the correct stub
        multiplexer = CommandMultiplexer(driver_stub, mission_stub, mode, logger)

        # Build the ZeroMQ poller which will poll for new messages
        poller = zmq.asyncio.Poller()
        poller.register(command_socket, zmq.POLLIN)

        # Track the last time we heard from the Swarm Controller
        last_manual_command_ts = None

        # Define asynchronous response handler
        async def handle_response(sck, mpx, msg):
            rsp = await mpx(msg)
            await sck.send(rsp)

        # Main handle loop
        while True:
            try:
                poll = dict(await poller.poll(timeout=0.5))
            except asyncio.exceptions.CancelledError:
                break
            except Exception as e:
                logger.error(
                        f"Error polling command socket, reason: {e}"
                        )

            # Skip our checks if no messages were delivered. However, if no
            # commands were recieved and we are in manual mode, go into 
            # failsafe
            if not len(poll):
                if (
                    mode.get_mode() == control_proto.ControlMode.REMOTE 
                    and last_manual_command_ts
                    and time.time() - last_manual_command_ts >= 1.0
                    ):
                    logger.warning(
                        "FAILSAFE ACTIVATED: Swarm controller is likely disconnected..."
                        )
                    # Send a Hold command (the request will be generated by
                    # the wrapper)
                    await multiplexer.failsafe() 
                    last_manual_command_ts = None
                continue

            last_manual_command_ts = time.time()
            message = await command_socket.recv()
            asyncio.create_task(
                    handle_response(
                        command_socket,
                        multiplexer,
                        message
                        )
                    )
     
async def serve_report_service():
    '''
    Serves the report service. This service allows to mission to send events
    to the Swarm Controller for coordination.
    '''
    # Read relevant endpoint from the config
    host_addr = query_config(
            'kernel.report_service.endpoint'
            ).split(':')[-1]
    host_url = f'[::]:{host_addr}'

    # Setup logger
    logger = CustomLogger('/kernel/report_service')

    # Setup the server
    server = grpc.aio.server(futures.ThreadPoolExecutor(max_workers=10))
    add_ReportServicer_to_server(ReportService(command_socket, logger), server)
    server.add_insecure_port(host_url)
    
    # Run the server
    logger.info('Created report server! Running service...')
    try:
        await server.start()
    except Exception as e:
        logger.error('Report server failed to start, reason: {e}')
    try:
        await server.wait_for_termination()
    except asyncio.exceptions.CancelledError:
        await server.stop(1)

async def serve_control_proxy_service():
    '''
    Serves the control proxy service. This service provides a wrapper around
    the driver control service for the mission module. It also controls
    access to the driver via its authorization interceptor.
    '''
    # Read relevant endpoints from the config
    driver_addr = query_config('driver.control_service.endpoint')
    host_addr = query_config(
            'kernel.control_proxy_service.endpoint'
            ).split(':')[-1]
    host_url = f'[::]:{host_addr}'
    
    # Setup logger
    logger = CustomLogger('/kernel/control_proxy_service')

    # Create a channel to the driver
    async with grpc.aio.insecure_channel(driver_addr) as channel:
        # Set up an interceptor for control authorization
        interceptor = [ControlAuth(mode, logger)]

        # Get the driver stub
        stub = DriverStub(channel)

        # Setup the server
        server = grpc.aio.server(
                futures.ThreadPoolExecutor(max_workers=10),
                interceptors=interceptor
                )
        add_DriverServicer_to_server(ControlProxyService(stub, logger), server)
        server.add_insecure_port(host_url)
        
        # Run the server
        logger.info('Created control proxy server! Running service...')
        try:
            await server.start()
        except Exception as e:
            logger.error('Control proxy server failed to start, reason: {e}')
        try:
            await server.wait_for_termination()
        except asyncio.exceptions.CancelledError:
            await server.stop(1)

async def main():
    try:
        sc_handler = asyncio.create_task(handle_swarm_control()) 
        report_service = asyncio.create_task(serve_report_service())
        control_proxy_service = asyncio.create_task(serve_control_proxy_service())
        await asyncio.gather(sc_handler, report_service, control_proxy_service)
    except asyncio.exceptions.CancelledError:
        sc_handler.cancel()
        report_service.cancel()
        control_proxy_service.cancel()
        await asyncio.gather(sc_handler, report_service, control_proxy_service)
        
if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print('\nControl manager cancelled, all services shut down.')
