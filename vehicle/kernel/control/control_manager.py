import time
import asyncio
import grpc
import zmq
import zmq.asyncio
# Service imports
from control.report_service import ReportService
from control.control_proxy_service import ControlProxyService
# Utility imports
from util.config import query_config
from util.custom_logger import get_logger
from util.zeromq import setup_zmq_socket
from util.auth import ControlAuth
from util.command_multiplexer import CommandMultiplexer
# Protocol imports
from python_bindings import control_pb2 as control_proto
from python_bindings.mission_service_pb2_grpc import MissionStub
from python_bindings.driver_service_pb2_grpc import DriverStub

class ControlMode:
    '''
    Mode switch to determine which entity has control of the vehicle.
    Must be wrapped in a class so it is pass-by-reference.
    -----------------------------------------------
    ControlMode.REMOTE -> Swarm Controller commands
    ControlMode.AUTONOMOUS -> Mission commands
    ControlMode.MANUAL -> Local joystick commands
    -----------------------------------------------
    '''
    def __init__(self, mode=control_proto.ControlMode.REMOTE):
        self._mode = mode

    def get_mode(self):
        return self._mode

    def switch_mode(self, mode):
        self._mode = mode

mode = ControlMode()

# Create ZeroMQ socket that connects to the Swarm Controller
command_socket = setup_zmq_socket(zmq.Context(),
    'cloudlet.swarm_controller.endpoint',
    SocketType.DEALER,
    SocketOperation.CONNECT
    )

async def handle_swarm_control():
    '''
    Handles input from the Swarm Controller for remote operation, mission 
    start/stop, and mission notification.
    '''
    # Read relevant endpoints from the config
    driver_addr = query_config('driver.control_service.endpoint')
    mission_addr = query_config('mission.mission_service.endpoint')

    # Setup logger
    logger = get_logger('/kernel/swarm_control')

    # Setup clients
    async with grpc.insecure_channel(driver_addr) as driver_channel, \
            grpc.insecure_channel(mission_addr) as mission_channel:
        # Get the driver stub wrapper which will help us translate
        # Swarm Controller commands into stub calls
        driver_stub = DriverStub(driver_channel)

        # Get the mission stub
        mission_stub = MissionStub(mission_channel) 

        # Create a command multiplexer that will send Swarm Controller
        # messages to the correct stub
        handler = CommandMultiplexer(driver_stub, mission_stub)

        # Build the ZeroMQ poller which will poll for new messages
        poller = zmq.asyncio.Poller()
        poller.register(command_socket, zmq.POLLIN)

        # Track the last time we heard from the Swarm Controller
        last_manual_command_ts = None

        # Main handle loop
        while True:
            poll = dict(await poller.poll(timeout=0.5))

            # Skip our checks if no messages were delivered. However, if no
            # commands were recieved and we are in manual mode, go into 
            # failsafe
            if not len(poll):
                if (
                    mode == telemetry_proto.ControlMode.REMOTE 
                    and last_manual_command_ts
                    and time.time() - last_manual_command_ts >= 1.0
                    ):
                    logger.warning(
                        "FAILSAFE ACTIVATED: Swarm controller is likely disconnected..."
                        )
                    # Send a Hold command (the request will be generated by
                    # the wrapper)
                    await handler.failsafe() 
                    last_manual_command_ts = None
                continue

            last_manual_command_ts = time.time()
            message = await command_socket.recv_multipart()
            response = await handler(message[0])


     
async def serve_report_service();
    '''
    Serves the report service. This service allows to mission to send events
    to the Swarm Controller for coordination.
    '''
    # Read relevant endpoint from the config
    host_addr = query_config(
            'kernel.report_service.endpoint'
            ).split(':')[-1]
    host_url = f'[::]:{host_addr}'

    # Setup logger
    logger = get_logger('/kernel/report_service')

    # Setup the server
    server = ReportService(command_socket, logger)
    server.add_insecure_port(host_url)
    
    # Run the server
    logger.info('Created report server! Running service...')
    try:
        await server.start()
        await server.wait_for_termination()
    except Exception as e:
        logger.error('Report server failed to start, reason: {e}')

async def serve_control_proxy_service():
    '''
    Serves the control proxy service. This service provides a wrapper around
    the driver control service for the mission module. It also controls
    access to the driver via its authorization interceptor.
    '''
    # Read relevant endpoints from the config
    driver_addr = query_config('driver.control_service.endpoint')
    host_addr = query_config(
            'kernel.control_proxy_service.endpoint'
            ).split(':')[-1]
    host_url = f'[::]:{host_addr}'
    
    # Setup logger
    logger = get_logger('/kernel/control_proxy_service')

    # Create a channel to the driver
    async with grpc.insecure_channel(driver_addr) as channel:
        # Set up an intercept channel with control authorization
        intercept_channel = grpc.intercept_channel(
            channel, ControlAuth(mode, logger)
        )

        # Get the driver stub
        driver_type = DriverStub(intercept_channel)

        # Setup the server
        server = ControlProxyService(stub, logger)
        server.add_insecure_port(host_addr)
        
        # Run the server
        logger.info('Created control proxy server! Running service...')
        try:
            await server.start()
            await server.wait_for_termination()
        except Exception as e:
            logger.error('Control proxy server failed to start, reason: {e}')

async def main():
    

if __name__ == "__main__":
    asyncio.run(main())
