import asyncio
import zmq
import zmq.asyncio
import inspect
import time
# Utility Import
from util.proto import read_any
from util.auth import ControlMode
# Multiplexer import
from command_multiplexer import CommandMultiplexer

class SwarmControlHandlerService:
    '''
    Service that handles input from the Swarm Controller for remote 
    operation, mission start/stop, and mission notification. Replicates
    the mission and control services over ZeroMQ.
    '''
    def __init__(
            self,
            auth,
            comm_sock,
            call_table,
            logger,
            failsafe=None
            ):
        # Create a command multiplexer that will send Swarm Controller
        # messages to the correct stub and return responses over the socket
        self._mpx = CommandMultiplexer(auth, comm_sock, call_table, failsafe, logger)

        # Set the auth object which will define access rights
        self._auth = auth
        self._comm_sock = comm_sock # Socket to Swarm Controller
        self._logger = logger
        self._timeout = None
        if failsafe:
            _, _, self._timeout = failsafe

    async def _handle(self):
        # Build the ZeroMQ poller which will poll for new messages
        poller = zmq.asyncio.Poller()
        poller.register(self._comm_sock, zmq.POLLIN)

        # Track the last time we heard from the Swarm Controller
        last_manual_command_ts = None

        # Main handle loop
        while True:
            try:
                poll = dict(await poller.poll(timeout=0.5))
            except asyncio.exceptions.CancelledError:
                break
            except Exception as e:
                logger.error(
                        f"Error polling command socket, reason: {e}"
                        )

            # Skip our checks if no messages were delivered. However, if no
            # commands were recieved and we are in manual self._mode, go into 
            # failsafe
            if not len(poll):
                if (
                    self._timeout != None \
                    and last_manual_command_ts \
                    and time.time() - last_manual_command_ts >= self._timeout \
                    and self._auth.get_mode == ControlMode.REMOTE
                    ):
                    logger.warning(
                        "FAILSAFE ACTIVATED: Swarm controller is likely disconnected..."
                        )
                    # Send a Hold command (the request will be generated by
                    # the wrapper)
                    await self._mpx.failsafe() 
                    last_manual_command_ts = None
                continue

            last_manual_command_ts = time.time()
            message = await self._comm_sock.recv()
            asyncio.create_task(
                    self._mpx(message)
                    )

    async def start(self):
        self._server = asyncio.create_task(self._handle())
        
    async def wait_for_termination(self):
        await self._server
