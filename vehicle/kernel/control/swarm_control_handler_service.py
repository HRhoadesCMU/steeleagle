import asyncio
import zmq
import zmq.asyncio
# Protocol import
from python_bindings import control_pb2 as control_proto
# Multiplexer import
from command_multiplexer import CommandMultiplexer

class SwarmControlHandlerService:
    '''
    Service that handles input from the Swarm Controller for remote 
    operation, mission start/stop, and mission notification. Replicates
    the mission and driver services over ZeroMQ.
    '''
    def __init__(
            self,
            driver_stub,
            mission_stub,
            mode,
            comm_sock,
            logger
            ):
        self._driver_stub = driver_stub
        self._mission_stub = mission_stub
        self._mode = mode # Control mode

        # Create a command multiplexer that will send Swarm Controller
        # messages to the correct stub
        self._mpx = CommandMultiplexer(driver_stub, mission_stub, mode, logger)

        self._comm_sock = comm_sock # Socket to Swarm Controller
        self._logger = logger
        self._exec_task = None

    async def _handle(self):
        # Build the ZeroMQ poller which will poll for new messages
        poller = zmq.asyncio.Poller()
        poller.register(self._comm_sock, zmq.POLLIN)

        # Track the last time we heard from the Swarm Controller
        last_manual_command_ts = None

        # Define asynchronous response handler
        async def handle_response(sck, mpx, msg):
            async for rsp in mpx(msg):
                await sck.send(rsp)

        # Main handle loop
        while True:
            try:
                poll = dict(await poller.poll(timeout=0.5))
            except asyncio.exceptions.CancelledError:
                break
            except Exception as e:
                logger.error(
                        f"Error polling command socket, reason: {e}"
                        )

            # Skip our checks if no messages were delivered. However, if no
            # commands were recieved and we are in manual self._mode, go into 
            # failsafe
            if not len(poll):
                if (
                    self._mode.get_mode() == control_proto.ControlMode.REMOTE \
                    and last_manual_command_ts \
                    and time.time() - last_manual_command_ts >= 1.0
                    ):
                    logger.warning(
                        "FAILSAFE ACTIVATED: Swarm controller is likely disconnected..."
                        )
                    # Send a Hold command (the request will be generated by
                    # the wrapper)
                    await self._mpx.failsafe() 
                    last_manual_command_ts = None
                continue

            print("Got command!")
            last_manual_command_ts = time.time()
            message = await self._comm_sock.recv()
            asyncio.create_task(
                    handle_response(
                        self._comm_sock,
                        self._mpx,
                        message
                        )
                    )

    async def start(self):
        self._exec_task = asyncio.create_task(self._handle())
        
    async def wait_for_termination(self):
        await self._exec_task
